{% extends 'layouts/page.njk' %}

{% block pageTitle %}Analysis Status{% endblock %}

{% block content %}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="/public/libs/xlsx.js"></script>
<script src="/public/libs/docx.js"></script>
<script src="/public/libs/filesaver.js"></script>
<a href="/Uploader" class="govuk-back-link no-print">Back to Upload</a>

<h1 class="govuk-heading-m no-print">Document Analysis Status</h1>

{% if markdownContent %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1em;">
  <h2 class="govuk-heading-m" style="margin: 0;">Analysis Results</h2>
  {% if status == 'completed' %}
  <div style="display: flex; gap: 10px;">
    <button id="exportPdfBtn" class="govuk-button no-print" style="background-color: #00703c; border-color: #00703c;" onclick="exportToPdf()">Export to PDF</button>
    <button id="exportExcelBtn" class="govuk-button no-print" style="background-color: #1d70b8; border-color: #1d70b8;" onclick="exportToExcel()">Export to Excel</button>
    <button id="exportWordBtn" class="govuk-button no-print" style="background-color: #d4351c; border-color: #d4351c;" onclick="exportToWord()">Export to Word</button>
  </div>
  {% endif %}
</div>
<div id="markdownContent" class="govuk-body markdown-content" style="margin-top: 1em; border: none;">
  <div id="markdownRenderer">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const markdownContent = {{ markdownContent | safe }};
        document.getElementById('markdownRenderer').innerHTML = marked.parse(markdownContent);
        
        // Apply GOV.UK styling to tables
        document.querySelectorAll('#markdownRenderer table').forEach((table) => {
          table.classList.add('govuk-table');
          table.querySelectorAll('thead').forEach((thead) => {
            thead.classList.add('govuk-table__head');
          });
          table.querySelectorAll('tbody').forEach((tbody) => {
            tbody.classList.add('govuk-table__body');
          });
          table.querySelectorAll('th').forEach((th) => {
            th.classList.add('govuk-table__header');
          });
          table.querySelectorAll('td').forEach((td) => {
            td.classList.add('govuk-table__cell');
          });
        });
      });
    </script>
  </div>
</div>
{% else %}
<div class="govuk-inset-text">
  <div class="spinner" style="display: inline-block; margin-right: 10px;"></div>
  {{ markdownContent or 'Processing your document analysis... Please wait while we fetch the results from our AI service.' }}
</div>
{% endif %}

<div id="errorMessage" class="govuk-error-summary" style="display: none;">
  <div class="govuk-error-summary__body">
    <p id="errorText"></p>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const requestId = '{{ requestId }}';
  const status = '{{ status }}';

  if (status === 'polling') {
    const startTime = Date.now();
    const maxDuration = 3 * 60 * 1000; // 3 minutes
    
    function pollProgress() {
      if (Date.now() - startTime > maxDuration) {
        document.querySelector('.govuk-inset-text').innerHTML = 
          '<p class="govuk-error-message">‚ö†Ô∏è Processing timeout: Analysis is taking longer than expected. Please try uploading your document again.</p>';
        return;
      }

      fetch(`/progress/${requestId}`)
        .then(response => {
          console.log('Response status:', response.status);
          return response.json();
        })
        .then(data => {         
          if (data.status === 'completed') {
            location.reload();
          } else {
            setTimeout(pollProgress, 5000);
          }
        })
        .catch(error => {
          console.error('Polling error:', error);
          setTimeout(pollProgress, 5000);
        });
    }
    
    pollProgress();
  } else if (status === 'completed') {
    console.log('Analysis already completed');
  }
});

function exportToPdf() {
  const style = document.createElement('style');
  style.innerHTML = `
    @media print {
      .no-print { display: none !important; }
      body * { visibility: hidden; }
      .print-header, .print-header * { visibility: visible; }
      #markdownRenderer, #markdownRenderer * { visibility: visible; }
      .print-header { position: absolute; left: 0; top: 0; width: 100%; }
      #markdownRenderer { position: absolute; left: 0; top: 80px; width: 100%; }
      .print-header .govuk-header__service-name { display: none !important; }
    }
  `;
  document.head.appendChild(style);
  
  window.print();
  
  setTimeout(() => {
    document.head.removeChild(style);
  }, 1000);
}



function exportToExcel() {
  const wb = XLSX.utils.book_new();
  const content = document.getElementById('markdownRenderer');
  const data = [];
  let rowIndex = 0;
  
  function processElement(element) {
    if (element.tagName === 'TABLE') {
      // Add table title if previous element was a heading
      const prevElement = element.previousElementSibling;
      if (prevElement && (prevElement.tagName === 'H1' || prevElement.tagName === 'H2' || prevElement.tagName === 'H3')) {
        data[rowIndex++] = [prevElement.innerText.trim()];
        data[rowIndex++] = [''];
      }
      
      // Process table rows
      Array.from(element.rows).forEach((tr, index) => {
        const rowData = [];
        Array.from(tr.cells).forEach(cell => {
          let text = cell.innerText.trim();
          // Remove emoji icons for cleaner Excel output
          text = text.replace(/üü¢|üü†|üî¥/g, '').trim();
          rowData.push(text);
        });
        data[rowIndex++] = rowData;
      });
      data[rowIndex++] = [''];
    } else if (element.tagName === 'H1' || element.tagName === 'H2' || element.tagName === 'H3') {
      // Only add heading if not followed by a table (table will handle it)
      const nextElement = element.nextElementSibling;
      if (!nextElement || nextElement.tagName !== 'TABLE') {
        const text = element.innerText.trim();
        if (text) {
          data[rowIndex++] = [text];
        }
      }
    } else if (element.tagName === 'P') {
      const text = element.innerText.trim();
      if (text) {
        data[rowIndex++] = [text];
      }
    } else if (element.tagName === 'UL' || element.tagName === 'OL') {
      Array.from(element.children).forEach(li => {
        const text = li.innerText.trim();
        if (text) {
          data[rowIndex++] = ['‚Ä¢ ' + text];
        }
      });
    }
  }
  
  // Process direct children to maintain structure
  Array.from(content.children).forEach(child => {
    processElement(child);
  });
  
  const ws = XLSX.utils.aoa_to_sheet(data);
  
  // Auto-size columns based on content
  const maxCols = Math.max(...data.map(row => row.length));
  ws['!cols'] = Array(maxCols).fill(0).map((_, i) => ({ wch: i === 0 ? 40 : 25 }));
  
  // Apply styling with color coding
  const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
  
  for (let R = range.s.r; R <= range.e.r; ++R) {
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cell_address = XLSX.utils.encode_cell({c: C, r: R});
      if (!ws[cell_address]) continue;
      
      const cellValue = ws[cell_address].v || '';
      const isHeader = R === 0 || (data[R] && data[R].length > 1 && R > 0 && data[R-1] && data[R-1][0] === '');
      let fillColor = 'FFFFFF';
      
      if (isHeader) {
        fillColor = 'E8F4FD';
      } else {
        // Check original content for emoji colors
        const tables = content.querySelectorAll('table');
        for (let table of tables) {
          const cells = table.querySelectorAll('td, th');
          for (let cell of cells) {
            const originalText = cell.innerText;
            const cleanText = originalText.replace(/üü¢|üü†|üî¥/g, '').trim();
            if (cleanText === cellValue) {
              if (originalText.includes('üü¢')) fillColor = 'C8E6C9';
              else if (originalText.includes('üü†')) fillColor = 'FFE0B2';
              else if (originalText.includes('üî¥')) fillColor = 'FFCDD2';
              break;
            }
          }
        }
      }
      
      ws[cell_address].s = {
        font: { bold: isHeader },
        alignment: { wrapText: true, vertical: 'top' },
        fill: { fgColor: { rgb: fillColor } },
        border: {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: { style: 'thin' },
          right: { style: 'thin' }
        }
      };
    }
  }
  
  XLSX.utils.book_append_sheet(wb, ws, 'Analysis Results');
  
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
  const filename = `document-analysis-${timestamp}.xlsx`;
  
  XLSX.writeFile(wb, filename);
}

function exportToWord() {
  const content = document.getElementById('markdownRenderer');
  const children = [];
  
  // Add title
  children.push(new docx.Paragraph({
    children: [new docx.TextRun({ text: "Document Analysis Results", bold: true, size: 32 })],
    spacing: { after: 400 }
  }));
  
  // Process all content including tables
  const elements = content.children;
  for (let element of elements) {
    if (element.tagName === 'TABLE') {
      const rows = Array.from(element.rows).map(row => 
        new docx.TableRow({
          children: Array.from(row.cells).map(cell => 
            new docx.TableCell({
              children: [new docx.Paragraph({ children: [new docx.TextRun(cell.innerText)] })]
            })
          )
        })
      );
      children.push(new docx.Table({ rows }));
    } else {
      children.push(new docx.Paragraph({
        children: [new docx.TextRun({ text: element.innerText, size: 24 })]
      }));
    }
  }
  
  const doc = new docx.Document({ sections: [{ properties: {}, children }] });
  
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
  const filename = `document-analysis-${timestamp}.docx`;
  
  docx.Packer.toBlob(doc).then(blob => {
    saveAs(blob, filename);
  });
}
</script>

{% endblock %}